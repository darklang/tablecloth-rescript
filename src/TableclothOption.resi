/** [Option](Option.mdx#) represents a value which may not be present.

  It is a variant containing the `Some('a)` and `None` constructors

  ```rescript
  type t<'a> =
  | Some('a)
  | None
  ```

  Many other languages use `null` or `nil` to represent something similar.

  [Option](Option.mdx#) values are very common and they are used in a number of ways:
  - Initial values
  - Optional function arguments
  - Optional record fields
  - Return values for functions that are not defined over their entire input range (partial functions).
  - Return value for otherwise reporting simple errors, where `None` is returned on error.

  Lots of functions in `Tablecloth` return options, one you have one you can
  work with the value it might contain by:

  - Pattern matching
  - Using [map](#map) or [andThen](#andThen)
  - Unwrapping it using [unwrap](#unwrap)
  - Converting a `None` into an exception using[unwrapUnsafe](#unwrapUnsafe)

  If the function you are writing can fail in a variety of ways, use a [Result](Result.mdx#) instead to
  better communicate with the caller.

  If a function only fails in unexpected, unrecoverable ways, maybe you want raise exception.
*/
type t<'a> = option<'a>

/** A function version of the `Some` constructor.

  In most situations you just want to use the `Some` constructor directly.

  Note that when using the Rescript syntax you *can* use fast pipe (`->`) with variant constructors, so you don't need this function.

  See the [Reason docs](https://rescript-lang.org/docs/manual/latest/pipe#pipe-into-variants) for more.

  ## Examples

  ```rescript
  String.reverse("desserts")->Option.some == Some("stressed")
  String.reverse("desserts")->Some == Some("stressed")
  ```
 */
let some: 'a => option<'a>

/** Returns `None` if the first argument is `None`, otherwise return the second argument.

  Unlike the built in `&&` operator, the `and_` function does not short-circuit.

  When you call `and_`, both arguments are evaluated before being passed to the function.

  ## Examples

  ```rescript
  Option.and_(Some(11), Some(22)) == Some(22)
  Option.and_(None, Some(22)) == None
  Option.and_(Some(11), None) == None
  Option.and_(None, None) == None
  ```
*/
let and_: (t<'a>, t<'a>) => t<'a>

/** Return the first argument if it [isSome](#isSome), otherwise return the second.

  Unlike the built in `||` operator, the `or_` function does not short-circuit.
  When you call `or_`, both arguments are evaluated before being passed to the function.

  ## Examples

  ```rescript
  Option.or_(Some(11), Some(22)) == Some(11)
  Option.or_(None, Some(22)) == Some(22)
  Option.or_(Some(11), None) == Some(11)
  Option.or_(None, None) == None
  ```
*/
let or_: (t<'a>, t<'a>) => t<'a>

/** Return the second argument if it [isSome](#isSome), otherwise return the first.

  Like [or_](#or_) but in reverse. Useful when using the `|>` operator

  ## Examples

  ```rescript
  Option.orElse(Some(11), Some(22)) == Some(22)
  Option.orElse(None, Some(22)) == Some(22)
  Option.orElse(Some(11), None) == Some(11)
  Option.orElse(None, None) == None
  ```
*/
let orElse: (t<'a>, t<'a>) => t<'a>

/** Transform two options into an option of a [Tuple2](Tuple2.mdx#).

  Returns None if either of the aguments is None.

  ## Examples

  ```rescript
  Option.both(Some(3004), Some("Ant")) == Some(3004, "Ant")
  Option.both(Some(3004), None) == None
  Option.both(None, Some("Ant")) == None
  Option.both(None, None) == None
  ```
*/
let both: (t<'a>, t<'b>) => t<('a, 'b)>

/** Flatten two optional layers into a single optional layer.

  ## Examples

  ```rescript
  Option.flatten(Some(Some(4))) == Some(4)
  Option.flatten(Some(None)) == None
  Option.flatten(None) == None
  ```
*/
let flatten: t<t<'a>> => t<'a>

/** Transform the value inside an option.

  Leaves `None` untouched.

  ## Examples

  ```rescript
  Option.map(~f=x => x * x, Some(9)) == Some(81)
  Option.map(~f=Int.toString, Some(9)) == Some("9")
  Option.map(~f=x => x * x, None) == None
  ```
*/
let map: (t<'a>, ~f: 'a => 'b) => t<'b>

/** Combine two [Option](Option.mdx#)s.

  If both options are `Some` returns, as `Some` the result of running `f` on both values.

  If either value is `None`, returns `None`.

  ## Examples

  ```rescript
  Option.map2(Some(3), Some(4), ~f=Int.add) == Some(7)
  Option.map2(Some(3), Some(4), ~f=Tuple.make) == Some(3, 4)
  Option.map2(Some(3), None, ~f=Int.add) == None
  Option.map2(None, Some(4), ~f=Int.add) == None
  ```
*/
let map2: (t<'a>, t<'b>, ~f: ('a, 'b) => 'c) => t<'c>

/** Chain together many computations that may not return a value.

  It is helpful to see its definition:

  ```rescript
  let andThen = (t, ~f) =>
  switch t {
  | Some(x) => f(x)
  | None => None
  }
  ```

  This means we only continue with the callback if we have a value.

  For example, say you need to parse some user input as a month:

  ```rescript
  let toValidMonth = (month) =>
  if 1 <= month && month <= 12 {
    Some(month)
  } else {
    None
  }

  let userInput = "5"

  Int.fromString(userInput)->Option.andThen(~f=toValidMonth)
  ```

  If `Int.fromString` produces `None` (because the `userInput` was not an
  integer) this entire chain of operations will short-circuit and result in
  `None`. If `toValidMonth` results in `None`, again the chain of
  computations will result in `None`.

  ## Examples

  ```rescript
  Option.andThen(Some([1, 2, 3]), ~f=Array.first) == Some(1)
  Option.andThen(Some([]), ~f=Array.first) == None
  ```
*/
let andThen: (t<'a>, ~f: 'a => t<'b>) => t<'b>

/** Unwrap an `option<'a>` returning `default` if called with `None`.

  This comes in handy when paired with functions like [Map.get](Map.mdx#get),
  [Array.first](Array.mdx#first) or [List.head](List.mdx#head) which return an [Option](Option.mdx#).

  *Note:* This can be overused! Many cases are better handled using pattern matching, [map](#map) or [andThen](#andThen).

  ## Examples

  ```rescript
  Option.unwrap(Some(42), ~default=99) == 42
  Option.unwrap(None, ~default=99) == 99
  Option.unwrap(Map.get(Map.String.empty, "Tom"), ~default="unknown") == "unknown"
  ```
*/
let unwrap: (t<'a>, ~default: 'a) => 'a

/** Unwrap an `option<'a>` returning the enclosed `'a`.

  *Note:* in most situations it is better to use pattern matching, [unwrap](#unwrap), [map](#map) or [andThen](#andThen).
  Can you structure your code slightly differently to avoid potentially raising an exception?

 ### Exceptions

  Raises an `Invalid_argument` exception if called with `None`

  ## Examples

  ```rescript
  Array.first([1, 2, 3])->Option.unwrapUnsafe == 1
  Array.first([])->Option.unwrapUnsafe // will raise Invalid_argument
  ```
*/
let unwrapUnsafe: t<'a> => 'a

/** Check if an [Option](Option.mdx#) is a `Some`.

  In most situtations you should just use pattern matching instead.

  ## Examples

  ```rescript
  Option.isSome(Some(3004)) == true
  Option.isSome(None) == false
  ```
*/
let isSome: t<'a> => bool

/** Check if an [Option](Option.mdx#) is a `None`.

  In most situtations you should just use pattern matching instead.

  ## Examples

  ```rescript
  Option.isNone(Some(3004)) == false
  Option.isNone(None) == true
  ```
*/
let isNone: t<'a> => bool

/** Run a function against an `Some(value)`, ignores `None`s.

  ## Examples

  ```rescript
  Option.tap(Some("Dog"), ~f=Js.log)
  (* logs "Dog" *)
  ``` 
*/
let tap: (t<'a>, ~f: 'a => unit) => unit

/** Convert an option to an [Array](Array.mdx#).

  `None` is represented as an empty array and `Some` is represented as an array of one element.

  ## Examples

  ```rescript
  Option.toArray(Some(3004)) == [3004]
  Option.toArray(None) == [
  ```
*/
let toArray: t<'a> => array<'a>

/** Convert an option to a [List](List.mdx#).

  `None` is represented as an empty list and `Some` is represented as a list of one element.

  ## Examples

  ```rescript
  Option.toList(Some(3004)) == list{3004}
  Option.toList(None) == list{}
  ```
*/
let toList: t<'a> => list<'a>

/** Test two optional values for equality using the provided function.

  ## Examples

  ```rescript
  Option.equal(Some(1), Some(1), Int.equal) == true
  Option.equal(Some(1), Some(3), Int.equal) == false
  Option.equal(Some(1), None, Int.equal) == false
  Option.equal(None, None, Int.equal) == true
  ```
*/
let equal: (t<'a>, t<'a>, ('a, 'a) => bool) => bool

/** Compare two optional values using the provided `f` function.

  A `None` is "less" than a `Some`.

  ## Examples

  ```rescript
  Option.compare(Some(1), Some(3), ~f=Int.compare) == -1
  Option.compare(Some(1), None, ~f=Int.compare) == 1
  Option.compare(None, None, ~f=Int.compare) == 0
  ```
*/
let compare: (t<'a>, t<'a>, ~f: ('a, 'a) => int) => int
